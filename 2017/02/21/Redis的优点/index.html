<!DOCTYPE html>
          <head>
        <meta charset="utf-8">
            
            <title>
                Redis的优点 | 匆匆过客
            </title>
            <meta content="width=device-width, initial-scale=1" name="viewport">
            <meta name="theme-color" content="#4184f3">
            
            
            <link href="/favicon.ico" rel="icon"/>
            

            <link rel="stylesheet" href="/css/highlight.light.css">
            <link rel="stylesheet" href="/css/prism-customize.css">
            <link rel="stylesheet" href="/css/nav-icon.css">
            <link rel="stylesheet" href="/css/waves.min.css">
            <link rel="stylesheet" href="/css/jquery.tocify.css">
            <link rel="stylesheet" href="/css/main.css">
            <link rel="stylesheet" href="/css/nav-indicator.css">
            
  

  
            </meta>
        </meta>
    <link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

    <body>
        <header>
            <!-- cover image or sth. -->
        </header>
        <div id="main" class="m-scene">
            
<div class="nav-wrapper">

    <div class="container">
        <nav>
            <div class="logo wave">
                <a href="/" id="logo">
                    匆匆过客
                </a>
            </div>
            <div class="nav-toggle-icon" >
                <div class="material-hamburger">
                    <span>
                    </span>
                    <span>
                    </span>
                    <span>
                    </span>
                </div>
            </div>
            <div class="menu-wrapper">
                <div class="nav-indicator">
                </div>
                <ul class="menus">
                    
                     
                        <li>
                            <a class="wave " href="/">
                                Home
                            </a>
                        </li>
                     
                        <li>
                            <a class="wave " href="/archives">
                                Archive
                            </a>
                        </li>
                     
                        <li>
                            <a class="wave " href="/about">
                                About
                            </a>
                        </li>
                     
                        <li>
                            <a class="wave no-smoothstate" href="/atom.xml">
                                RSS
                            </a>
                        </li>
                     
                    
                   
                </ul>
            </div>
        </nav>
    </div>
</div>
            <div class="container content">
                <div class="scene_element scene_element--fadein">
                    <div class="row">
    <div class="main">
        <article>
          
          <header class="post-header">
          
          </header>
          <h1 class="post-title">Redis的优点</h1>

          <section class="post-info">
            <span class="post-date">2017/02/21</span>
            
            <span class="post-category">
                <a class="article-category-link" href="/categories/Redis/">Redis</a>
            </span>
            
            
            <span class="post-tags">
              <ul class="post-tag-list"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/redis/">redis</a></li></ul>
            </span>
            
          </section>

          <section class="post-content">
            <h2 id="Redis的优点"><a href="/2017/02/21/Redis的优点/#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><ol>
<li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li>
<li>支持丰富数据类型，支持string，list，set，sorted set，hash</li>
<li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>
<li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li>
</ol>
<h2 id="Redis与其他一些数据库和缓存服务器的特性与功能的对比如下："><a href="/2017/02/21/Redis的优点/#Redis与其他一些数据库和缓存服务器的特性与功能的对比如下：" class="headerlink" title="Redis与其他一些数据库和缓存服务器的特性与功能的对比如下："></a>Redis与其他一些数据库和缓存服务器的特性与功能的对比如下：</h2><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数据存储选项</th>
<th>查询类型</th>
<th>附加功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis</td>
<td>使用内存存储（in-memory）的非关系数据库</td>
<td>字符串、列表、集合、散列表、有序集合</td>
<td>每种数据类型都有自己的专属命令，另外还有批量操作（bulk operation）和不完全（partial）的事务支持</td>
<td>发布与订阅，主从复制（master/slave replication），持久化，脚本（存储过程，stored procedure）</td>
</tr>
<tr>
<td>memcached</td>
<td>使用内存存储的键值缓存</td>
<td>键值之间的映射</td>
<td>创建命令、读取命令、更新命令、删除命令以及其他几个命令</td>
<td>为提升性能而设的多线程服务器</td>
</tr>
<tr>
<td>MongoDB</td>
<td>使用硬盘存储（on-disk）的非关系文档存储</td>
<td>每个数据库可以包含多个表，每个表可以包含多个无schema（schema-less）的BSON文档</td>
<td>创建命令、读取命令、更新命令、删除命令、条件查询命令等</td>
<td>支持map-reduce操作，主从复制，分片，空间索引（spatial index）</td>
</tr>
</tbody>
</table>
<h2 id="Redis的持久化方式"><a href="/2017/02/21/Redis的优点/#Redis的持久化方式" class="headerlink" title="Redis的持久化方式"></a>Redis的持久化方式</h2><p>在使用类似Redis这样的内存数据库时，一个首先要考虑的问题就是“当服务器被关闭时，服务器存储的数据将何去何从呢？”</p>
<p>　　Redis拥有两种不同形式的持久化方法，它们都可以用小而紧凑的格式将存储在内存中的数据写入硬盘：</p>
<p>　　第一种持久化方法为RDB，即时间点转储（point-in-time dump）。有一份数据，就把这一份数据整体保存一份，每隔一定的时间就保存一下数据，保存的是最终的结果。转储操作既可以在“指定时间段内有指定数量的写操作执行”这一条件被满足时执行，又可以通过调用两条转储到硬盘（dump-to-disk）命令中的任何一条来执行；</p>
<p>　　第二种持久化方法是AOF，将所有修改了数据库的命令都写入一个只追加（append-only）文件里面，保存的是命令操作。用户可以根据数据的重要程度，将只追加写入设置为从不同步（sync）、每秒同步一次或者每写入一个命令就同步一次。
　　</p>
<h2 id="Redis的主从同步"><a href="/2017/02/21/Redis的优点/#Redis的主从同步" class="headerlink" title="Redis的主从同步"></a>Redis的主从同步</h2><p>Redis实现了主从复制特性：执行复制的从服务器会连接上主服务器，接收主服务器发送的整个数据库的初始副本（copy）；之后主服务器执行的写命令，都会被发送给所有连接着的从服务器去执行，从而实时地更新从服务器的数据集。因为从服务器包含的数据会不断地进行更新，所以客户端可以向任意一个从服务器发送读请求，以此来避免对主服务器进行集中式的访问。</p>
<h2 id="Redis的value的数据类型"><a href="/2017/02/21/Redis的优点/#Redis的value的数据类型" class="headerlink" title="Redis的value的数据类型"></a>Redis的value的数据类型</h2><ol>
<li>String（字符串）</li>
</ol>
<p>string是redis最基本的类型，一个key对应一个value。<br>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。<br>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<ul>
<li>常用命令<br>除了get、set、incr、decr mget等操作外，Redis还提供了下面一些操作：</li>
</ul>
<p>获取字符串长度<br>往字符串append内容<br>设置和获取字符串的某一段内容<br>设置及获取字符串的某一位（bit）<br>批量设置一系列字符串的内容</p>
<ul>
<li><p>应用场景<br>　　String是最常用的一种数据类型，普通的key/value存储都可以归为此类，value其实不仅是String， 也可以是数字：比如想知道什么时候封锁一个IP地址(访问超过几次)。INCRBY命令让这些变得很容易，通过原子递增保持计数。</p>
</li>
<li><p>实现方式<br>　　m,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// get,set</div><div class="line">jedis.set(&quot;hello&quot;, &quot;world&quot;);</div><div class="line">print(1, jedis.get(&quot;hello&quot;));</div><div class="line">jedis.rename(&quot;hello&quot;, &quot;newhello&quot;);</div><div class="line">print(1, jedis.get(&quot;newhello&quot;));</div><div class="line">jedis.setex(&quot;hello2&quot;, 15, &quot;world&quot;);</div><div class="line">// 数值操作</div><div class="line">jedis.set(&quot;pv&quot;, &quot;100&quot;);</div><div class="line">jedis.incr(&quot;pv&quot;);</div><div class="line">jedis.decrBy(&quot;pv&quot;, 5);</div><div class="line">print(2, jedis.get(&quot;pv&quot;));</div><div class="line">print(3, jedis.keys(&quot;*&quot;));</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>List（列表）</li>
</ol>
<p>　　Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表最多可存储 2^32 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<ul>
<li><p>常用命令<br>　　lpush,rpush,lpop,rpop,lrange,BLPOP(阻塞版)等。</p>
</li>
<li><p>应用场景<br>　　Redis list的应用场景非常多，也是Redis最重要的数据结构之一。</p>
</li>
</ul>
<p>　　我们可以轻松地实现最新消息、排行榜等功能（比如新浪微博的 TimeLine ）。</p>
<p>　　Lists的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。</p>
<ul>
<li><p>实现方式<br>　　Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 列表操作, 最近来访, 粉丝列表，消息队列</div><div class="line">String listName = &quot;list&quot;;</div><div class="line">jedis.del(listName);</div><div class="line">for (int i = 0; i &lt; 10; ++i) &#123;</div><div class="line">    jedis.lpush(listName, &quot;a&quot; + String.valueOf(i));</div><div class="line">&#125;</div><div class="line">print(4, jedis.lrange(listName, 0, 12)); // 最近来访10个id</div><div class="line">print(5, jedis.llen(listName));</div><div class="line">print(6, jedis.lpop(listName));</div><div class="line">print(7, jedis.llen(listName));</div><div class="line">print(8, jedis.lrange(listName, 2, 6)); // 最近来访10个id</div><div class="line">print(9, jedis.lindex(listName, 3));</div><div class="line">print(10, jedis.linsert(listName, BinaryClient.LIST_POSITION.AFTER, &quot;a4&quot;, &quot;xx&quot;));</div><div class="line">print(10, jedis.linsert(listName, BinaryClient.LIST_POSITION.BEFORE, &quot;a4&quot;, &quot;bb&quot;));</div><div class="line">print(11, jedis.lrange(listName, 0, 12));</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Set（集合）"><a href="/2017/02/21/Redis的优点/#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>　　Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<ul>
<li><p>常用命令<br>　　sadd,srem,spop,sdiff ,smembers,sunion 等。</p>
</li>
<li><p>应用场景<br>　　Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
</li>
</ul>
<p>共同好友、二度好友<br>利用唯一性，可以统计访问网站的所有独立 IP<br>好友推荐的时候，根据 tag 求交集，大于某个 threshold 就可以推荐<br>　　在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p>
<ul>
<li><p>实现方式<br>　　set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">String likeKey1 = &quot;newsLike1&quot;;</div><div class="line">String likeKey2 = &quot;newsLike2&quot;;</div><div class="line">for (int i = 0; i &lt; 10; ++i) &#123;</div><div class="line">    jedis.sadd(likeKey1, String.valueOf(i));</div><div class="line">    jedis.sadd(likeKey2, String.valueOf(i * 2));</div><div class="line">&#125;</div><div class="line">print(20, jedis.smembers(likeKey1));</div><div class="line">print(21, jedis.smembers(likeKey2));</div><div class="line">print(22, jedis.sunion(likeKey1, likeKey2));</div><div class="line">print(23, jedis.sdiff(likeKey1, likeKey2));</div><div class="line">print(24, jedis.sinter(likeKey1, likeKey2));</div><div class="line">print(25, jedis.sismember(likeKey1, &quot;12&quot;));</div><div class="line">print(26, jedis.sismember(likeKey2, &quot;12&quot;));</div><div class="line">jedis.srem(likeKey1, &quot;5&quot;);</div><div class="line">print(27, jedis.smembers(likeKey1));</div><div class="line">// 从1移动到2</div><div class="line">jedis.smove(likeKey2, likeKey1, &quot;14&quot;);</div><div class="line">print(28, jedis.smembers(likeKey1));</div><div class="line">print(29, jedis.scard(likeKey1));</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Hash（哈希）"><a href="/2017/02/21/Redis的优点/#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>　Redis hash 是一个键值对集合。它是一个string类型的field和value的映射表，hash特别适合用于存储对象。集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<ul>
<li><p>常用命令<br>　　hget,hset,hgetall 等。</p>
</li>
<li><p>应用场景<br>　　存储、读取、修改用户属性。</p>
</li>
</ul>
<p>　　Redis的Hash实际是内部存储的Value为一个HashMap， 并提供了直接存取这个Map成员的接口， 如：hmset user:001 name “李三” age 18 birthday “20010101” ，也就是说，Key仍然是用户ID,value是一个Map，这个Map的key是成员的属性名，value是属性值， 这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。Redis 的 Hash 结构可以像在数据库中 Update 一个属性一样只修改某一项属性值。</p>
<ul>
<li><p>实现方式<br>　　Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// hash, 可变字段</div><div class="line">String userKey = &quot;userxx&quot;;</div><div class="line">jedis.hset(userKey, &quot;name&quot;, &quot;jim&quot;);</div><div class="line">jedis.hset(userKey, &quot;age&quot;, &quot;12&quot;);</div><div class="line">jedis.hset(userKey, &quot;phone&quot;, &quot;18666666666&quot;);</div><div class="line">print(12, jedis.hget(userKey, &quot;name&quot;));</div><div class="line">print(13, jedis.hgetAll(userKey));</div><div class="line">jedis.hdel(userKey, &quot;phone&quot;);</div><div class="line">print(14, jedis.hgetAll(userKey));</div><div class="line">print(15, jedis.hexists(userKey, &quot;email&quot;));</div><div class="line">print(16, jedis.hexists(userKey, &quot;age&quot;));</div><div class="line">print(17, jedis.hkeys(userKey));</div><div class="line">print(18, jedis.hvals(userKey));</div><div class="line">jedis.hsetnx(userKey, &quot;school&quot;, &quot;zju&quot;);//这个方法是先判断有没有这个字段，没有的话才进行设置</div><div class="line">jedis.hsetnx(userKey, &quot;name&quot;, &quot;yxy&quot;);</div><div class="line">print(19, jedis.hgetAll(userKey));</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="zset-sorted-set：有序集合"><a href="/2017/02/21/Redis的优点/#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>　　Redis zset 和 set 一tring类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<ul>
<li><p>常用命令　<br>　　zadd,zrange,zrem,zcard等</p>
</li>
<li><p>使用场景　<br>带有权重的元素，比如一个游戏的用户得分排行榜<br>比较复杂的数据结构，一般用到的场景不算太多<br>　　以某个条件为权重，比如按顶的次数排序。ZREVRANGE命令可以用来按照得分来获取前100名的用户，ZRANK可以用来获取用户排名，非常直接而且操作容易。</p>
</li>
</ul>
<p>　　Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。比如:twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。比如:全班同学成绩的SortedSets，value可以是同学的学号，而score就可以是其考试得分，这样数据插入集合的，就已经进行了天然的排序。</p>
<p>　　另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
<ul>
<li><p>实现方式<br>　　Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 排序集合，有限队列，排行榜</div><div class="line">String rankKey = &quot;rankKey&quot;;</div><div class="line">jedis.zadd(rankKey, 15, &quot;Jim&quot;);</div><div class="line">jedis.zadd(rankKey, 60, &quot;Ben&quot;);</div><div class="line">jedis.zadd(rankKey, 90, &quot;Lee&quot;);</div><div class="line">jedis.zadd(rankKey, 75, &quot;Lucy&quot;);</div><div class="line">jedis.zadd(rankKey, 80, &quot;Mei&quot;);</div><div class="line">print(30, jedis.zcard(rankKey));</div><div class="line">print(31, jedis.zcount(rankKey, 61, 100));</div><div class="line">// 改错卷了</div><div class="line">print(32, jedis.zscore(rankKey, &quot;Lucy&quot;));</div><div class="line">jedis.zincrby(rankKey, 2, &quot;Lucy&quot;);</div><div class="line">print(33, jedis.zscore(rankKey, &quot;Lucy&quot;));</div><div class="line">jedis.zincrby(rankKey, 2, &quot;Luc&quot;);</div><div class="line">print(34, jedis.zscore(rankKey, &quot;Luc&quot;));</div><div class="line">print(35, jedis.zcount(rankKey, 0, 100));</div><div class="line">// 1-4 名 Luc</div><div class="line">print(36, jedis.zrange(rankKey, 0, 10));</div><div class="line">print(36, jedis.zrange(rankKey, 1, 3));</div><div class="line">print(36, jedis.zrevrange(rankKey, 1, 3));</div><div class="line">for (Tuple tuple : jedis.zrangeByScoreWithScores(rankKey, &quot;60&quot;, &quot;100&quot;)) &#123;</div><div class="line">    print(37, tuple.getElement() + &quot;:&quot; + String.valueOf(tuple.getScore()));</div><div class="line">&#125;</div><div class="line">print(38, jedis.zrank(rankKey, &quot;Ben&quot;));</div><div class="line">print(39, jedis.zrevrank(rankKey, &quot;Ben&quot;));</div><div class="line">String setKey = &quot;zset&quot;;</div><div class="line">jedis.zadd(setKey, 1, &quot;a&quot;);</div><div class="line">jedis.zadd(setKey, 1, &quot;b&quot;);</div><div class="line">jedis.zadd(setKey, 1, &quot;c&quot;);</div><div class="line">jedis.zadd(setKey, 1, &quot;d&quot;);</div><div class="line">jedis.zadd(setKey, 1, &quot;e&quot;);</div><div class="line">print(40, jedis.zlexcount(setKey, &quot;-&quot;, &quot;+&quot;));</div><div class="line">print(41, jedis.zlexcount(setKey, &quot;(b&quot;, &quot;[d&quot;));</div><div class="line">print(42, jedis.zlexcount(setKey, &quot;[b&quot;, &quot;[d&quot;));</div><div class="line">jedis.zrem(setKey, &quot;b&quot;);</div><div class="line">print(43, jedis.zrange(setKey, 0, 10));</div><div class="line">jedis.zremrangeByLex(setKey, &quot;(c&quot;, &quot;+&quot;);</div><div class="line">print(44, jedis.zrange(setKey, 0, 2));</div></pre></td></tr></table></figure>
</li>
</ul>

          </section>
        </article>
        

       

         <!-- comments -->
        <div class="comment-section">
  
    


</div>

    </div>
    
</div>

                </div>
            </div>
        </div>
        <footer class="footer">
    <p>由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动，搭载<a href="https://github.com/wayou/hexo-theme-gstyle">gstyle</a>主题</p>
    <p>
        &copy; 2017 roy.cai
    </p>
</footer>
<script src="/lib/jquery.js"></script>
<script src="/lib/waves.js"></script>
<script src="/lib/jquery-ui.js"></script>
<script src="/lib/jquery.tocify.js"></script>
<script src="/js/main.js"></script>

    </body>
</html>
